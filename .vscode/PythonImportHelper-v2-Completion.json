[
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "genfromtxt",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "Pipeline",
        "importPath": "sklearn.pipeline",
        "description": "sklearn.pipeline",
        "isExtraImport": true,
        "detail": "sklearn.pipeline",
        "documentation": {}
    },
    {
        "label": "Pipeline",
        "importPath": "sklearn.pipeline",
        "description": "sklearn.pipeline",
        "isExtraImport": true,
        "detail": "sklearn.pipeline",
        "documentation": {}
    },
    {
        "label": "Pipeline",
        "importPath": "sklearn.pipeline",
        "description": "sklearn.pipeline",
        "isExtraImport": true,
        "detail": "sklearn.pipeline",
        "documentation": {}
    },
    {
        "label": "Pipeline",
        "importPath": "sklearn.pipeline",
        "description": "sklearn.pipeline",
        "isExtraImport": true,
        "detail": "sklearn.pipeline",
        "documentation": {}
    },
    {
        "label": "Pipeline",
        "importPath": "sklearn.pipeline",
        "description": "sklearn.pipeline",
        "isExtraImport": true,
        "detail": "sklearn.pipeline",
        "documentation": {}
    },
    {
        "label": "make_classification",
        "importPath": "sklearn.datasets",
        "description": "sklearn.datasets",
        "isExtraImport": true,
        "detail": "sklearn.datasets",
        "documentation": {}
    },
    {
        "label": "make_classification",
        "importPath": "sklearn.datasets",
        "description": "sklearn.datasets",
        "isExtraImport": true,
        "detail": "sklearn.datasets",
        "documentation": {}
    },
    {
        "label": "StandardScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "StandardScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "StandardScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "label_binarize",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "label_binarize",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "PowerTransformer",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "LabelEncoder",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "StandardScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "GridSearchCV",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "KFold",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "GridSearchCV",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "GridSearchCV",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "LeavePOut",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "StratifiedKFold",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "KFold",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "GridSearchCV",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "LeavePOut",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "StratifiedKFold",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "KNeighborsClassifier",
        "importPath": "sklearn.neighbors",
        "description": "sklearn.neighbors",
        "isExtraImport": true,
        "detail": "sklearn.neighbors",
        "documentation": {}
    },
    {
        "label": "KNeighborsClassifier",
        "importPath": "sklearn.neighbors",
        "description": "sklearn.neighbors",
        "isExtraImport": true,
        "detail": "sklearn.neighbors",
        "documentation": {}
    },
    {
        "label": "KNeighborsClassifier",
        "importPath": "sklearn.neighbors",
        "description": "sklearn.neighbors",
        "isExtraImport": true,
        "detail": "sklearn.neighbors",
        "documentation": {}
    },
    {
        "label": "KNeighborsClassifier",
        "importPath": "sklearn.neighbors",
        "description": "sklearn.neighbors",
        "isExtraImport": true,
        "detail": "sklearn.neighbors",
        "documentation": {}
    },
    {
        "label": "KNeighborsClassifier",
        "importPath": "sklearn.neighbors",
        "description": "sklearn.neighbors",
        "isExtraImport": true,
        "detail": "sklearn.neighbors",
        "documentation": {}
    },
    {
        "label": "KNeighborsClassifier",
        "importPath": "sklearn.neighbors",
        "description": "sklearn.neighbors",
        "isExtraImport": true,
        "detail": "sklearn.neighbors",
        "documentation": {}
    },
    {
        "label": "KNeighborsClassifier",
        "importPath": "sklearn.neighbors",
        "description": "sklearn.neighbors",
        "isExtraImport": true,
        "detail": "sklearn.neighbors",
        "documentation": {}
    },
    {
        "label": "LogisticRegression",
        "importPath": "sklearn.linear_model",
        "description": "sklearn.linear_model",
        "isExtraImport": true,
        "detail": "sklearn.linear_model",
        "documentation": {}
    },
    {
        "label": "LogisticRegression",
        "importPath": "sklearn.linear_model",
        "description": "sklearn.linear_model",
        "isExtraImport": true,
        "detail": "sklearn.linear_model",
        "documentation": {}
    },
    {
        "label": "LogisticRegression",
        "importPath": "sklearn.linear_model",
        "description": "sklearn.linear_model",
        "isExtraImport": true,
        "detail": "sklearn.linear_model",
        "documentation": {}
    },
    {
        "label": "LogisticRegression",
        "importPath": "sklearn.linear_model",
        "description": "sklearn.linear_model",
        "isExtraImport": true,
        "detail": "sklearn.linear_model",
        "documentation": {}
    },
    {
        "label": "RandomForestClassifier",
        "importPath": "sklearn.ensemble",
        "description": "sklearn.ensemble",
        "isExtraImport": true,
        "detail": "sklearn.ensemble",
        "documentation": {}
    },
    {
        "label": "RandomForestClassifier",
        "importPath": "sklearn.ensemble",
        "description": "sklearn.ensemble",
        "isExtraImport": true,
        "detail": "sklearn.ensemble",
        "documentation": {}
    },
    {
        "label": "RandomForestClassifier",
        "importPath": "sklearn.ensemble",
        "description": "sklearn.ensemble",
        "isExtraImport": true,
        "detail": "sklearn.ensemble",
        "documentation": {}
    },
    {
        "label": "RandomForestClassifier",
        "importPath": "sklearn.ensemble",
        "description": "sklearn.ensemble",
        "isExtraImport": true,
        "detail": "sklearn.ensemble",
        "documentation": {}
    },
    {
        "label": "SelectKBest",
        "importPath": "sklearn.feature_selection",
        "description": "sklearn.feature_selection",
        "isExtraImport": true,
        "detail": "sklearn.feature_selection",
        "documentation": {}
    },
    {
        "label": "mutual_info_classif",
        "importPath": "sklearn.feature_selection",
        "description": "sklearn.feature_selection",
        "isExtraImport": true,
        "detail": "sklearn.feature_selection",
        "documentation": {}
    },
    {
        "label": "f_classif",
        "importPath": "sklearn.feature_selection",
        "description": "sklearn.feature_selection",
        "isExtraImport": true,
        "detail": "sklearn.feature_selection",
        "documentation": {}
    },
    {
        "label": "SelectKBest",
        "importPath": "sklearn.feature_selection",
        "description": "sklearn.feature_selection",
        "isExtraImport": true,
        "detail": "sklearn.feature_selection",
        "documentation": {}
    },
    {
        "label": "SelectKBest",
        "importPath": "sklearn.feature_selection",
        "description": "sklearn.feature_selection",
        "isExtraImport": true,
        "detail": "sklearn.feature_selection",
        "documentation": {}
    },
    {
        "label": "mutual_info_classif",
        "importPath": "sklearn.feature_selection",
        "description": "sklearn.feature_selection",
        "isExtraImport": true,
        "detail": "sklearn.feature_selection",
        "documentation": {}
    },
    {
        "label": "SelectFdr",
        "importPath": "sklearn.feature_selection",
        "description": "sklearn.feature_selection",
        "isExtraImport": true,
        "detail": "sklearn.feature_selection",
        "documentation": {}
    },
    {
        "label": "SelectFdr",
        "importPath": "sklearn.feature_selection",
        "description": "sklearn.feature_selection",
        "isExtraImport": true,
        "detail": "sklearn.feature_selection",
        "documentation": {}
    },
    {
        "label": "chi2",
        "importPath": "sklearn.feature_selection",
        "description": "sklearn.feature_selection",
        "isExtraImport": true,
        "detail": "sklearn.feature_selection",
        "documentation": {}
    },
    {
        "label": "f_classif",
        "importPath": "sklearn.feature_selection",
        "description": "sklearn.feature_selection",
        "isExtraImport": true,
        "detail": "sklearn.feature_selection",
        "documentation": {}
    },
    {
        "label": "RFE",
        "importPath": "sklearn.feature_selection",
        "description": "sklearn.feature_selection",
        "isExtraImport": true,
        "detail": "sklearn.feature_selection",
        "documentation": {}
    },
    {
        "label": "SelectKBest",
        "importPath": "sklearn.feature_selection",
        "description": "sklearn.feature_selection",
        "isExtraImport": true,
        "detail": "sklearn.feature_selection",
        "documentation": {}
    },
    {
        "label": "SelectKBest",
        "importPath": "sklearn.feature_selection",
        "description": "sklearn.feature_selection",
        "isExtraImport": true,
        "detail": "sklearn.feature_selection",
        "documentation": {}
    },
    {
        "label": "mutual_info_classif",
        "importPath": "sklearn.feature_selection",
        "description": "sklearn.feature_selection",
        "isExtraImport": true,
        "detail": "sklearn.feature_selection",
        "documentation": {}
    },
    {
        "label": "SelectFdr",
        "importPath": "sklearn.feature_selection",
        "description": "sklearn.feature_selection",
        "isExtraImport": true,
        "detail": "sklearn.feature_selection",
        "documentation": {}
    },
    {
        "label": "SelectFdr",
        "importPath": "sklearn.feature_selection",
        "description": "sklearn.feature_selection",
        "isExtraImport": true,
        "detail": "sklearn.feature_selection",
        "documentation": {}
    },
    {
        "label": "chi2",
        "importPath": "sklearn.feature_selection",
        "description": "sklearn.feature_selection",
        "isExtraImport": true,
        "detail": "sklearn.feature_selection",
        "documentation": {}
    },
    {
        "label": "f_classif",
        "importPath": "sklearn.feature_selection",
        "description": "sklearn.feature_selection",
        "isExtraImport": true,
        "detail": "sklearn.feature_selection",
        "documentation": {}
    },
    {
        "label": "RFE",
        "importPath": "sklearn.feature_selection",
        "description": "sklearn.feature_selection",
        "isExtraImport": true,
        "detail": "sklearn.feature_selection",
        "documentation": {}
    },
    {
        "label": "VarianceThreshold",
        "importPath": "sklearn.feature_selection",
        "description": "sklearn.feature_selection",
        "isExtraImport": true,
        "detail": "sklearn.feature_selection",
        "documentation": {}
    },
    {
        "label": "randint",
        "importPath": "numpy.random",
        "description": "numpy.random",
        "isExtraImport": true,
        "detail": "numpy.random",
        "documentation": {}
    },
    {
        "label": "rand",
        "importPath": "numpy.random",
        "description": "numpy.random",
        "isExtraImport": true,
        "detail": "numpy.random",
        "documentation": {}
    },
    {
        "label": "rand",
        "importPath": "numpy.random",
        "description": "numpy.random",
        "isExtraImport": true,
        "detail": "numpy.random",
        "documentation": {}
    },
    {
        "label": "randint",
        "importPath": "numpy.random",
        "description": "numpy.random",
        "isExtraImport": true,
        "detail": "numpy.random",
        "documentation": {}
    },
    {
        "label": "choice",
        "importPath": "numpy.random",
        "description": "numpy.random",
        "isExtraImport": true,
        "detail": "numpy.random",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "heapq",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "heapq",
        "description": "heapq",
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "scipy.io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy.io",
        "description": "scipy.io",
        "detail": "scipy.io",
        "documentation": {}
    },
    {
        "label": "arff",
        "importPath": "scipy.io",
        "description": "scipy.io",
        "isExtraImport": true,
        "detail": "scipy.io",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "repeat",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Pool",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "freeze_support",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Process",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Pool",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Process",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Pool",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "statistics",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "statistics",
        "description": "statistics",
        "detail": "statistics",
        "documentation": {}
    },
    {
        "label": "chi2_contingency",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "process_map",
        "importPath": "tqdm.contrib.concurrent",
        "description": "tqdm.contrib.concurrent",
        "isExtraImport": true,
        "detail": "tqdm.contrib.concurrent",
        "documentation": {}
    },
    {
        "label": "faiss",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "faiss",
        "description": "faiss",
        "detail": "faiss",
        "documentation": {}
    },
    {
        "label": "classification_report",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "make_scorer",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "matthews_corrcoef",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "roc_auc_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "accuracy_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "average_precision_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "make_scorer",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "matthews_corrcoef",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "roc_auc_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "accuracy_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "average_precision_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "precision_recall_curve",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "make_scorer",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "matthews_corrcoef",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "roc_auc_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "accuracy_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "average_precision_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "make_scorer",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "matthews_corrcoef",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "roc_auc_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "accuracy_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "average_precision_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "precision_recall_curve",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "roc_curve",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "auc",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "scipy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy",
        "description": "scipy",
        "detail": "scipy",
        "documentation": {}
    },
    {
        "label": "jfs",
        "importPath": "feature_algo.dssa",
        "description": "feature_algo.dssa",
        "isExtraImport": true,
        "detail": "feature_algo.dssa",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "KEY_OPTIONS",
        "importPath": "curses",
        "description": "curses",
        "isExtraImport": true,
        "detail": "curses",
        "documentation": {}
    },
    {
        "label": "KEY_OPTIONS",
        "importPath": "curses",
        "description": "curses",
        "isExtraImport": true,
        "detail": "curses",
        "documentation": {}
    },
    {
        "label": "Pool",
        "importPath": "multiprocessing.dummy",
        "description": "multiprocessing.dummy",
        "isExtraImport": true,
        "detail": "multiprocessing.dummy",
        "documentation": {}
    },
    {
        "label": "Pool",
        "importPath": "multiprocessing.dummy",
        "description": "multiprocessing.dummy",
        "isExtraImport": true,
        "detail": "multiprocessing.dummy",
        "documentation": {}
    },
    {
        "label": "BaseEstimator",
        "importPath": "sklearn.base",
        "description": "sklearn.base",
        "isExtraImport": true,
        "detail": "sklearn.base",
        "documentation": {}
    },
    {
        "label": "TransformerMixin",
        "importPath": "sklearn.base",
        "description": "sklearn.base",
        "isExtraImport": true,
        "detail": "sklearn.base",
        "documentation": {}
    },
    {
        "label": "BaseEstimator",
        "importPath": "sklearn.base",
        "description": "sklearn.base",
        "isExtraImport": true,
        "detail": "sklearn.base",
        "documentation": {}
    },
    {
        "label": "TransformerMixin",
        "importPath": "sklearn.base",
        "description": "sklearn.base",
        "isExtraImport": true,
        "detail": "sklearn.base",
        "documentation": {}
    },
    {
        "label": "BaseEstimator",
        "importPath": "sklearn.base",
        "description": "sklearn.base",
        "isExtraImport": true,
        "detail": "sklearn.base",
        "documentation": {}
    },
    {
        "label": "TransformerMixin",
        "importPath": "sklearn.base",
        "description": "sklearn.base",
        "isExtraImport": true,
        "detail": "sklearn.base",
        "documentation": {}
    },
    {
        "label": "BaseEstimator",
        "importPath": "sklearn.base",
        "description": "sklearn.base",
        "isExtraImport": true,
        "detail": "sklearn.base",
        "documentation": {}
    },
    {
        "label": "TransformerMixin",
        "importPath": "sklearn.base",
        "description": "sklearn.base",
        "isExtraImport": true,
        "detail": "sklearn.base",
        "documentation": {}
    },
    {
        "label": "BaseEstimator",
        "importPath": "sklearn.base",
        "description": "sklearn.base",
        "isExtraImport": true,
        "detail": "sklearn.base",
        "documentation": {}
    },
    {
        "label": "TransformerMixin",
        "importPath": "sklearn.base",
        "description": "sklearn.base",
        "isExtraImport": true,
        "detail": "sklearn.base",
        "documentation": {}
    },
    {
        "label": "SVC",
        "importPath": "sklearn.svm",
        "description": "sklearn.svm",
        "isExtraImport": true,
        "detail": "sklearn.svm",
        "documentation": {}
    },
    {
        "label": "SVC",
        "importPath": "sklearn.svm",
        "description": "sklearn.svm",
        "isExtraImport": true,
        "detail": "sklearn.svm",
        "documentation": {}
    },
    {
        "label": "SVC",
        "importPath": "sklearn.svm",
        "description": "sklearn.svm",
        "isExtraImport": true,
        "detail": "sklearn.svm",
        "documentation": {}
    },
    {
        "label": "SVC",
        "importPath": "sklearn.svm",
        "description": "sklearn.svm",
        "isExtraImport": true,
        "detail": "sklearn.svm",
        "documentation": {}
    },
    {
        "label": "SVC",
        "importPath": "sklearn.svm",
        "description": "sklearn.svm",
        "isExtraImport": true,
        "detail": "sklearn.svm",
        "documentation": {}
    },
    {
        "label": "SVC",
        "importPath": "sklearn.svm",
        "description": "sklearn.svm",
        "isExtraImport": true,
        "detail": "sklearn.svm",
        "documentation": {}
    },
    {
        "label": "PCA",
        "importPath": "sklearn.decomposition",
        "description": "sklearn.decomposition",
        "isExtraImport": true,
        "detail": "sklearn.decomposition",
        "documentation": {}
    },
    {
        "label": "PCA",
        "importPath": "sklearn.decomposition",
        "description": "sklearn.decomposition",
        "isExtraImport": true,
        "detail": "sklearn.decomposition",
        "documentation": {}
    },
    {
        "label": "GaussianNB",
        "importPath": "sklearn.naive_bayes",
        "description": "sklearn.naive_bayes",
        "isExtraImport": true,
        "detail": "sklearn.naive_bayes",
        "documentation": {}
    },
    {
        "label": "GaussianNB",
        "importPath": "sklearn.naive_bayes",
        "description": "sklearn.naive_bayes",
        "isExtraImport": true,
        "detail": "sklearn.naive_bayes",
        "documentation": {}
    },
    {
        "label": "mkdtemp",
        "importPath": "tempfile",
        "description": "tempfile",
        "isExtraImport": true,
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "mkdtemp",
        "importPath": "tempfile",
        "description": "tempfile",
        "isExtraImport": true,
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "Memory",
        "importPath": "joblib",
        "description": "joblib",
        "isExtraImport": true,
        "detail": "joblib",
        "documentation": {}
    },
    {
        "label": "Memory",
        "importPath": "joblib",
        "description": "joblib",
        "isExtraImport": true,
        "detail": "joblib",
        "documentation": {}
    },
    {
        "label": "rmtree",
        "importPath": "shutil",
        "description": "shutil",
        "isExtraImport": true,
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "rmtree",
        "importPath": "shutil",
        "description": "shutil",
        "isExtraImport": true,
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "ReliefF",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ReliefF",
        "description": "ReliefF",
        "detail": "ReliefF",
        "documentation": {}
    },
    {
        "label": "MRMR",
        "importPath": "skfeature.function.information_theoretical_based",
        "description": "skfeature.function.information_theoretical_based",
        "isExtraImport": true,
        "detail": "skfeature.function.information_theoretical_based",
        "documentation": {}
    },
    {
        "label": "MRMR",
        "importPath": "skfeature.function.information_theoretical_based",
        "description": "skfeature.function.information_theoretical_based",
        "isExtraImport": true,
        "detail": "skfeature.function.information_theoretical_based",
        "documentation": {}
    },
    {
        "label": "Pool",
        "importPath": "multiprocessing.pool",
        "description": "multiprocessing.pool",
        "isExtraImport": true,
        "detail": "multiprocessing.pool",
        "documentation": {}
    },
    {
        "label": "Pool",
        "importPath": "multiprocessing.pool",
        "description": "multiprocessing.pool",
        "isExtraImport": true,
        "detail": "multiprocessing.pool",
        "documentation": {}
    },
    {
        "label": "ThreadPool",
        "importPath": "multiprocessing.pool",
        "description": "multiprocessing.pool",
        "isExtraImport": true,
        "detail": "multiprocessing.pool",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "Genetic_FA",
        "importPath": "feature_algo.Genetic_FA",
        "description": "feature_algo.Genetic_FA",
        "isExtraImport": true,
        "detail": "feature_algo.Genetic_FA",
        "documentation": {}
    },
    {
        "label": "Genetic_FA",
        "importPath": "feature_algo.Genetic_FA",
        "description": "feature_algo.Genetic_FA",
        "isExtraImport": true,
        "detail": "feature_algo.Genetic_FA",
        "documentation": {}
    },
    {
        "label": "default_timer",
        "importPath": "timeit",
        "description": "timeit",
        "isExtraImport": true,
        "detail": "timeit",
        "documentation": {}
    },
    {
        "label": "default_timer",
        "importPath": "timeit",
        "description": "timeit",
        "isExtraImport": true,
        "detail": "timeit",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "dssa",
        "importPath": "feature_algo",
        "description": "feature_algo",
        "isExtraImport": true,
        "detail": "feature_algo",
        "documentation": {}
    },
    {
        "label": "SimpleImputer",
        "importPath": "sklearn.impute",
        "description": "sklearn.impute",
        "isExtraImport": true,
        "detail": "sklearn.impute",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "walk",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "listdir",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "comparison",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "comparison",
        "description": "comparison",
        "detail": "comparison",
        "documentation": {}
    },
    {
        "label": "isfile",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "Genetic_FA",
        "kind": 6,
        "importPath": "feature_algo.Genetic_FA",
        "description": "feature_algo.Genetic_FA",
        "peekOfCode": "class Genetic_FA():\n    # def __init__(self ) -> None:\n    def fit(self,X,y):\n        #split the data into train and validation\n        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)\n        self.n_features = min(500,X_train.shape[1] )\n        k_best = SelectKBest(f_classif, k=self.n_features).fit(X_train, y_train)\n        self.X_train_kbest_valid=k_best.transform(X_train)\n        self.X_valid_kbest_valid=k_best.transform(X_test)\n        self.y_train_valid=y_train",
        "detail": "feature_algo.Genetic_FA",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "feature_algo.Genetic_FA",
        "description": "feature_algo.Genetic_FA",
        "peekOfCode": "def main():\n    n_features = 500\n    ga=Genetic_FA(X_train_kbest,X_valid_kbest_valid,y_train_valid, y_valid_valid,n_features)\n    r=ga.fit() \n    # mat =scipy.io.loadmat('scikit-Dataset/TOX-171.mat')\n    # X=mat['X']\n    # y = mat['Y'][:, 0] \n    # X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, stratify=y,  random_state=40)\n    # k_best = SelectKBest(f_classif, k=500).fit(X_train, y_train)\n    # X_train_kbest = k_best.transform(X_train)",
        "detail": "feature_algo.Genetic_FA",
        "documentation": {}
    },
    {
        "label": "contingency_table",
        "kind": 2,
        "importPath": "feature_algo.Genetic_FA",
        "description": "feature_algo.Genetic_FA",
        "peekOfCode": "def contingency_table(a,b,total):\n    obs = np.array([[a,total-a ], [b,total-b]])\n    chi2, p, dof, ex =chi2_contingency(obs)\n    # print(p)\n    if p>0.05:\n        return True\n    else:\n        return False\nclass Genetic_FA():\n    # def __init__(self ) -> None:",
        "detail": "feature_algo.Genetic_FA",
        "documentation": {}
    },
    {
        "label": "error_rate",
        "kind": 2,
        "importPath": "feature_algo.dssa",
        "description": "feature_algo.dssa",
        "peekOfCode": "def error_rate(xt, xv, yt, yv, x):\n    # parameters\n    k = 5\n    # Number of instances\n    num_train = np.size(xt, 0)\n    num_valid = np.size(xv, 0)\n    # Define selected features\n    xtrain = xt[:, x == 1]\n    ytrain = yt.reshape(num_train)  # Solve bug\n    xvalid = xv[:, x == 1]",
        "detail": "feature_algo.dssa",
        "documentation": {}
    },
    {
        "label": "Fun",
        "kind": 2,
        "importPath": "feature_algo.dssa",
        "description": "feature_algo.dssa",
        "peekOfCode": "def Fun(xt, xv, yt, yv, x):\n    # Parameters\n    alpha = 0.99\n    beta = 1 - alpha\n    # Original feature size\n    max_feat = len(x)\n    # Number of selected features\n    num_feat = np.sum(x == 1)\n    # Solve if no feature selected\n    if num_feat == 0:",
        "detail": "feature_algo.dssa",
        "documentation": {}
    },
    {
        "label": "init_position",
        "kind": 2,
        "importPath": "feature_algo.dssa",
        "description": "feature_algo.dssa",
        "peekOfCode": "def init_position(lb, ub, N, dim):\n    X = np.zeros([N, dim], dtype='float')\n    for i in range(N):\n        for d in range(dim):\n            X[i,d] = lb[0,d] + (ub[0,d] - lb[0,d]) * rand()        \n    return X\ndef binary_conversion(X, thres, N, dim):\n    Xbin = np.zeros([N, dim], dtype='int')\n    for i in range(N):\n        for d in range(dim):",
        "detail": "feature_algo.dssa",
        "documentation": {}
    },
    {
        "label": "binary_conversion",
        "kind": 2,
        "importPath": "feature_algo.dssa",
        "description": "feature_algo.dssa",
        "peekOfCode": "def binary_conversion(X, thres, N, dim):\n    Xbin = np.zeros([N, dim], dtype='int')\n    for i in range(N):\n        for d in range(dim):\n            if X[i,d] > thres:\n                Xbin[i,d] = 1\n            else:\n                Xbin[i,d] = 0\n    return Xbin\ndef boundary(x, lb, ub):",
        "detail": "feature_algo.dssa",
        "documentation": {}
    },
    {
        "label": "boundary",
        "kind": 2,
        "importPath": "feature_algo.dssa",
        "description": "feature_algo.dssa",
        "peekOfCode": "def boundary(x, lb, ub):\n    if x < lb:\n        x = lb\n    if x > ub:\n        x = ub\n    return x\ndef LSA(fitF, Xbin, xt, xv, yt, yv, max_it = 10):\n    t1 = fitF\n    k = 1\n    while k <= max_it:",
        "detail": "feature_algo.dssa",
        "documentation": {}
    },
    {
        "label": "LSA",
        "kind": 2,
        "importPath": "feature_algo.dssa",
        "description": "feature_algo.dssa",
        "peekOfCode": "def LSA(fitF, Xbin, xt, xv, yt, yv, max_it = 10):\n    t1 = fitF\n    k = 1\n    while k <= max_it:\n        num_features = choice([2, 5])\n        feature_numbers = randint(0, Xbin.size, num_features)\n        for feature in feature_numbers:\n            if Xbin[feature] == 1:\n                Xbin[feature] = 0\n            else:",
        "detail": "feature_algo.dssa",
        "documentation": {}
    },
    {
        "label": "fit",
        "kind": 2,
        "importPath": "feature_algo.dssa",
        "description": "feature_algo.dssa",
        "peekOfCode": "def fit(x, y):\n    # Parameters\n    ub    = 1\n    lb    = 0\n    thres = 0.5\n    N        = 10\n    max_iter = 100\n    M = random.uniform(0.9, 1.08)\n    U_Value = rand()\n    xtrain, xval, ytrain, yval = train_test_split(x, y, test_size=0.3, stratify=y)",
        "detail": "feature_algo.dssa",
        "documentation": {}
    },
    {
        "label": "mat",
        "kind": 5,
        "importPath": "Demo_PSO",
        "description": "Demo_PSO",
        "peekOfCode": "mat = scipy.io.loadmat('Data/scikit_TOX-171.mat')\nfeat=mat['X']\nlabel = mat['Y'][:, 0]\n# split data into train, validation and test\nxtrain, xtest, ytrain, ytest = train_test_split(feat, label, test_size=0.3, stratify=label)\nxtrain, xval, ytrain, yval = train_test_split(xtrain, ytrain, test_size=0.3, stratify=ytrain)\nfold = {'xt':xtrain, 'yt':ytrain, 'xv':xval, 'yv':yval}\nscaler = StandardScaler()\nxtrain = scaler.fit_transform(xtrain)\nxval = scaler.transform(xval)",
        "detail": "Demo_PSO",
        "documentation": {}
    },
    {
        "label": "label",
        "kind": 5,
        "importPath": "Demo_PSO",
        "description": "Demo_PSO",
        "peekOfCode": "label = mat['Y'][:, 0]\n# split data into train, validation and test\nxtrain, xtest, ytrain, ytest = train_test_split(feat, label, test_size=0.3, stratify=label)\nxtrain, xval, ytrain, yval = train_test_split(xtrain, ytrain, test_size=0.3, stratify=ytrain)\nfold = {'xt':xtrain, 'yt':ytrain, 'xv':xval, 'yv':yval}\nscaler = StandardScaler()\nxtrain = scaler.fit_transform(xtrain)\nxval = scaler.transform(xval)\nxtest = scaler.transform(xtest)\n# parameter",
        "detail": "Demo_PSO",
        "documentation": {}
    },
    {
        "label": "fold",
        "kind": 5,
        "importPath": "Demo_PSO",
        "description": "Demo_PSO",
        "peekOfCode": "fold = {'xt':xtrain, 'yt':ytrain, 'xv':xval, 'yv':yval}\nscaler = StandardScaler()\nxtrain = scaler.fit_transform(xtrain)\nxval = scaler.transform(xval)\nxtest = scaler.transform(xtest)\n# parameter\nk    = 5     # k-value in KNN\nN    = 10    # number of particles\nT    = 100   # maximum number of iterations\nM = random.uniform(0.9, 1.08)",
        "detail": "Demo_PSO",
        "documentation": {}
    },
    {
        "label": "scaler",
        "kind": 5,
        "importPath": "Demo_PSO",
        "description": "Demo_PSO",
        "peekOfCode": "scaler = StandardScaler()\nxtrain = scaler.fit_transform(xtrain)\nxval = scaler.transform(xval)\nxtest = scaler.transform(xtest)\n# parameter\nk    = 5     # k-value in KNN\nN    = 10    # number of particles\nT    = 100   # maximum number of iterations\nM = random.uniform(0.9, 1.08)\nopts = {'k':k, 'fold':fold, 'N':N, 'T':T, 'M': M}",
        "detail": "Demo_PSO",
        "documentation": {}
    },
    {
        "label": "xtrain",
        "kind": 5,
        "importPath": "Demo_PSO",
        "description": "Demo_PSO",
        "peekOfCode": "xtrain = scaler.fit_transform(xtrain)\nxval = scaler.transform(xval)\nxtest = scaler.transform(xtest)\n# parameter\nk    = 5     # k-value in KNN\nN    = 10    # number of particles\nT    = 100   # maximum number of iterations\nM = random.uniform(0.9, 1.08)\nopts = {'k':k, 'fold':fold, 'N':N, 'T':T, 'M': M}\n# perform feature selection",
        "detail": "Demo_PSO",
        "documentation": {}
    },
    {
        "label": "xval",
        "kind": 5,
        "importPath": "Demo_PSO",
        "description": "Demo_PSO",
        "peekOfCode": "xval = scaler.transform(xval)\nxtest = scaler.transform(xtest)\n# parameter\nk    = 5     # k-value in KNN\nN    = 10    # number of particles\nT    = 100   # maximum number of iterations\nM = random.uniform(0.9, 1.08)\nopts = {'k':k, 'fold':fold, 'N':N, 'T':T, 'M': M}\n# perform feature selection\nfmdl = jfs(xtrain, ytrain, opts)",
        "detail": "Demo_PSO",
        "documentation": {}
    },
    {
        "label": "xtest",
        "kind": 5,
        "importPath": "Demo_PSO",
        "description": "Demo_PSO",
        "peekOfCode": "xtest = scaler.transform(xtest)\n# parameter\nk    = 5     # k-value in KNN\nN    = 10    # number of particles\nT    = 100   # maximum number of iterations\nM = random.uniform(0.9, 1.08)\nopts = {'k':k, 'fold':fold, 'N':N, 'T':T, 'M': M}\n# perform feature selection\nfmdl = jfs(xtrain, ytrain, opts)\nsf   = fmdl['sf']",
        "detail": "Demo_PSO",
        "documentation": {}
    },
    {
        "label": "M",
        "kind": 5,
        "importPath": "Demo_PSO",
        "description": "Demo_PSO",
        "peekOfCode": "M = random.uniform(0.9, 1.08)\nopts = {'k':k, 'fold':fold, 'N':N, 'T':T, 'M': M}\n# perform feature selection\nfmdl = jfs(xtrain, ytrain, opts)\nsf   = fmdl['sf']\n# model with selected features\nnum_train = np.size(xtrain, 0)\nnum_valid = np.size(xtest, 0)\nx_train   = xtrain[:, sf]\ny_train   = ytrain.reshape(num_train)  # Solve bug",
        "detail": "Demo_PSO",
        "documentation": {}
    },
    {
        "label": "opts",
        "kind": 5,
        "importPath": "Demo_PSO",
        "description": "Demo_PSO",
        "peekOfCode": "opts = {'k':k, 'fold':fold, 'N':N, 'T':T, 'M': M}\n# perform feature selection\nfmdl = jfs(xtrain, ytrain, opts)\nsf   = fmdl['sf']\n# model with selected features\nnum_train = np.size(xtrain, 0)\nnum_valid = np.size(xtest, 0)\nx_train   = xtrain[:, sf]\ny_train   = ytrain.reshape(num_train)  # Solve bug\nx_valid   = xtest[:, sf]",
        "detail": "Demo_PSO",
        "documentation": {}
    },
    {
        "label": "fmdl",
        "kind": 5,
        "importPath": "Demo_PSO",
        "description": "Demo_PSO",
        "peekOfCode": "fmdl = jfs(xtrain, ytrain, opts)\nsf   = fmdl['sf']\n# model with selected features\nnum_train = np.size(xtrain, 0)\nnum_valid = np.size(xtest, 0)\nx_train   = xtrain[:, sf]\ny_train   = ytrain.reshape(num_train)  # Solve bug\nx_valid   = xtest[:, sf]\ny_valid   = ytest.reshape(num_valid)  # Solve bug\nmdl       = KNeighborsClassifier(n_neighbors = k) ",
        "detail": "Demo_PSO",
        "documentation": {}
    },
    {
        "label": "num_train",
        "kind": 5,
        "importPath": "Demo_PSO",
        "description": "Demo_PSO",
        "peekOfCode": "num_train = np.size(xtrain, 0)\nnum_valid = np.size(xtest, 0)\nx_train   = xtrain[:, sf]\ny_train   = ytrain.reshape(num_train)  # Solve bug\nx_valid   = xtest[:, sf]\ny_valid   = ytest.reshape(num_valid)  # Solve bug\nmdl       = KNeighborsClassifier(n_neighbors = k) \nmdl.fit(x_train, y_train)\n# accuracy\ny_pred    = mdl.predict(x_valid)",
        "detail": "Demo_PSO",
        "documentation": {}
    },
    {
        "label": "num_valid",
        "kind": 5,
        "importPath": "Demo_PSO",
        "description": "Demo_PSO",
        "peekOfCode": "num_valid = np.size(xtest, 0)\nx_train   = xtrain[:, sf]\ny_train   = ytrain.reshape(num_train)  # Solve bug\nx_valid   = xtest[:, sf]\ny_valid   = ytest.reshape(num_valid)  # Solve bug\nmdl       = KNeighborsClassifier(n_neighbors = k) \nmdl.fit(x_train, y_train)\n# accuracy\ny_pred    = mdl.predict(x_valid)\nAcc       = np.sum(y_valid == y_pred)  / num_valid",
        "detail": "Demo_PSO",
        "documentation": {}
    },
    {
        "label": "num_feat",
        "kind": 5,
        "importPath": "Demo_PSO",
        "description": "Demo_PSO",
        "peekOfCode": "num_feat = fmdl['nf']\nprint(\"Feature Size:\", num_feat)\n# # plot convergence\n# curve   = fmdl['c']\n# curve   = curve.reshape(np.size(curve,1))\n# x       = np.arange(0, opts['T'], 1.0) + 1.0\n#\n# fig, ax = plt.subplots()\n# ax.plot(x, curve, 'o-')\n# ax.set_xlabel('Number of Iterations')",
        "detail": "Demo_PSO",
        "documentation": {}
    },
    {
        "label": "NoDaemonProcess",
        "kind": 6,
        "importPath": "comparison copy",
        "description": "comparison copy",
        "peekOfCode": "class NoDaemonProcess(Process):\n    def _get_daemon(self):\n        return False\n    def _set_daemon(self, value):\n        pass\n    daemon = property(_get_daemon, _set_daemon)\nclass MyPool(PoolParent):\n    Process = NoDaemonProcess\n# FS_ALGO_LIST= [\"MRMR\",\"SVM\"]\n# FS_ALGO_LIST= [\"f_classif\"]",
        "detail": "comparison copy",
        "documentation": {}
    },
    {
        "label": "MyPool",
        "kind": 6,
        "importPath": "comparison copy",
        "description": "comparison copy",
        "peekOfCode": "class MyPool(PoolParent):\n    Process = NoDaemonProcess\n# FS_ALGO_LIST= [\"MRMR\",\"SVM\"]\n# FS_ALGO_LIST= [\"f_classif\"]\nFS_ALGO_LIST= [\"f_classif\",\"MRMR\",\"ReliefF\"]\n# FS_ALGO_LIST= [\"SVM\"]\nK_OPTIONS= [1, 2, 3, 4, 5, 10, 15, 20, 25, 30, 50, 100]\n# K_OPTIONS= [50]\ndef get_clf_dict():\n    return {'LogisticRegression': LogisticRegression(),",
        "detail": "comparison copy",
        "documentation": {}
    },
    {
        "label": "get_clf_dict",
        "kind": 2,
        "importPath": "comparison copy",
        "description": "comparison copy",
        "peekOfCode": "def get_clf_dict():\n    return {'LogisticRegression': LogisticRegression(),\n            'RandomForestClassifier': RandomForestClassifier(),\n            'KNeighborsClassifier': KNeighborsClassifier(),\n            'GaussianNB': GaussianNB(),\n            'SVC': SVC(probability=True)}\n# def my_score(X, y):\n#     return mutual_info_regression(X, y, random_state=0)\nfrom sklearn.preprocessing import label_binarize\ndef evalute(y_true,y_pred, y_prob):",
        "detail": "comparison copy",
        "documentation": {}
    },
    {
        "label": "evalute",
        "kind": 2,
        "importPath": "comparison copy",
        "description": "comparison copy",
        "peekOfCode": "def evalute(y_true,y_pred, y_prob):\n    if y_prob.shape[1] ==2:\n        multi_class=False\n        y_prob=y_prob[:,0]\n        pr_auc= average_precision_score(y_true, y_prob)\n        auc= roc_auc_score(y_true, y_prob)\n    else:\n        np.argmax(y_prob, 0)\n        bin_y= label_binarize(y_pred, classes=range(y_prob.shape[1]))\n        pr_auc= average_precision_score(bin_y, y_prob, average=\"micro\")",
        "detail": "comparison copy",
        "documentation": {}
    },
    {
        "label": "feature_selection",
        "kind": 2,
        "importPath": "comparison copy",
        "description": "comparison copy",
        "peekOfCode": "def feature_selection(fs_algo,X_train, y_train):\n    #TODO: need to add out features, SVM\n    start = timer()\n    if  fs_algo==\"f_classif\":\n        return SelectFdr(score_func=f_classif,alpha=0.1).fit(X_train,y_train),timer()-start\n    elif fs_algo==\"MRMR\":\n        return SelectKBest(score_func=MRMR.mrmr,k=100).fit(X_train, y_train),timer()-start\n    elif fs_algo==\"ReliefF\":\n        return SelectKBest(score_func=ReliefF.ReliefF,k=100).fit(X_train, y_train),timer()-start\n    elif fs_algo==\"SVM\":",
        "detail": "comparison copy",
        "documentation": {}
    },
    {
        "label": "calculate_per_FS_algo",
        "kind": 2,
        "importPath": "comparison copy",
        "description": "comparison copy",
        "peekOfCode": "def calculate_per_FS_algo(fs_algo,X_train=[],X_test=[], y_train=[],y_test=[]):\n    res={}\n    clf_list= get_clf_dict().items()\n    empty_feature=False\n    best_feature,fs_time = feature_selection(fs_algo,X_train, y_train)\n    res['fs_time']= fs_time\n    if fs_algo==\"SelectFdr\":\n        if best_feature.pvalues_==None:\n            empty_feature=True\n    if not empty_feature:",
        "detail": "comparison copy",
        "documentation": {}
    },
    {
        "label": "run_fold",
        "kind": 2,
        "importPath": "comparison copy",
        "description": "comparison copy",
        "peekOfCode": "def run_fold(indexes,db=[]):\n    # print(\"Running fold {}\".format(indexes))\n    fold_n,(train,test)= indexes\n    results={}\n    print(\"Fold: \", fold_n)\n    results[fold_n]={}\n    train = db[train]\n    test =  db[test]\n    X_train= train[:,:-1]\n    y_train= train[:,-1]",
        "detail": "comparison copy",
        "documentation": {}
    },
    {
        "label": "clf_res",
        "kind": 2,
        "importPath": "comparison copy",
        "description": "comparison copy",
        "peekOfCode": "def clf_res(res,clf):\n    # res= k_value_dict[k][clf]\n    clf_df= pd.DataFrame.from_dict(res)\n    clf_df.index = clf_df.index.set_names(['metric'])\n    clf_df.reset_index(inplace=True)\n    clf_df[\"Learning algorithm\"]= clf\n    return clf_df\ndef turn_resDict_to_df(results):\n    all_df=[]\n    for fold,fs_algo_lst in results.items():",
        "detail": "comparison copy",
        "documentation": {}
    },
    {
        "label": "turn_resDict_to_df",
        "kind": 2,
        "importPath": "comparison copy",
        "description": "comparison copy",
        "peekOfCode": "def turn_resDict_to_df(results):\n    all_df=[]\n    for fold,fs_algo_lst in results.items():\n        for fs_algo in fs_algo_lst:\n            for fs_algo_name in fs_algo.keys():\n                k_value_dict= fs_algo[fs_algo_name]\n                k_df= pd.DataFrame()\n                fs_time= k_value_dict[\"fs_time\"]\n                for k in list(k_value_dict.keys())[1:]:\n                    res_df= pd.DataFrame()",
        "detail": "comparison copy",
        "documentation": {}
    },
    {
        "label": "run_grid_search",
        "kind": 2,
        "importPath": "comparison copy",
        "description": "comparison copy",
        "peekOfCode": "def run_grid_search(db):\n    results={}\n    if len(db)<50:\n        fold_func = LeavePOut(2)\n    elif len(db)<=100:\n        fold_func = LeavePOut(1)\n    elif len(db)<=1000:\n        fold_func = StratifiedKFold(n_splits=10)\n    else:\n        fold_func = StratifiedKFold(n_splits=5)",
        "detail": "comparison copy",
        "documentation": {}
    },
    {
        "label": "NoDaemonProcess",
        "kind": 6,
        "importPath": "comparison",
        "description": "comparison",
        "peekOfCode": "class NoDaemonProcess(Process):\n    def _get_daemon(self):\n        return False\n    def _set_daemon(self, value):\n        pass\n    daemon = property(_get_daemon, _set_daemon)\nclass MyPool(PoolParent):\n    Process = NoDaemonProcess\n# FS_ALGO_LIST= [\"MRMR\",\"SVM\"]\nFS_ALGO_LIST= [\"f_classif\",\"ReliefF\"]",
        "detail": "comparison",
        "documentation": {}
    },
    {
        "label": "MyPool",
        "kind": 6,
        "importPath": "comparison",
        "description": "comparison",
        "peekOfCode": "class MyPool(PoolParent):\n    Process = NoDaemonProcess\n# FS_ALGO_LIST= [\"MRMR\",\"SVM\"]\nFS_ALGO_LIST= [\"f_classif\",\"ReliefF\"]\n# FS_ALGO_LIST= [\"ReliefF\"]\n# FS_ALGO_LIST= [\"f_classif\",\"MRMR\",\"ReliefF\"]\n# FS_ALGO_LIST= [\"dssa\",\"f_classif\",\"MRMR\",\"ReliefF\"]\n# K_OPTIONS= [1, 2, 3, 4, 5, 10, 15, 20, 25, 30, 50, 100]\nK_OPTIONS= [50,100]\ndef run_grid_search(db):",
        "detail": "comparison",
        "documentation": {}
    },
    {
        "label": "get_clf_dict",
        "kind": 2,
        "importPath": "comparison",
        "description": "comparison",
        "peekOfCode": "def get_clf_dict():\n    return {'LogisticRegression': LogisticRegression(),\n            # 'RandomForestClassifier': RandomForestClassifier(),\n            'KNeighborsClassifier': KNeighborsClassifier(),\n            'GaussianNB': GaussianNB(),\n            'SVC': SVC(probability=True)}\nclass NoDaemonProcess(Process):\n    def _get_daemon(self):\n        return False\n    def _set_daemon(self, value):",
        "detail": "comparison",
        "documentation": {}
    },
    {
        "label": "run_grid_search",
        "kind": 2,
        "importPath": "comparison",
        "description": "comparison",
        "peekOfCode": "def run_grid_search(db):\n    X= db[:,:-1]\n    y= db[:,-1]\n    with MyPool(processes=len(FS_ALGO_LIST)) as pool:\n        results= pool.map(partial(calculate_per_FS_algo,X=X,y=y)\n                                  ,FS_ALGO_LIST)\n    results= {k: v for d in results for k, v in d.items()}\n    return results           \ndef calculate_per_FS_algo(fs_algo,X=[],y=[]):\n    print(\"Calculating for {}\".format(fs_algo))",
        "detail": "comparison",
        "documentation": {}
    },
    {
        "label": "calculate_per_FS_algo",
        "kind": 2,
        "importPath": "comparison",
        "description": "comparison",
        "peekOfCode": "def calculate_per_FS_algo(fs_algo,X=[],y=[]):\n    print(\"Calculating for {}\".format(fs_algo))\n    res={}\n    clf_list= get_clf_dict().items()\n    empty_feature=False\n    best_feature,fs_time = feature_selection(fs_algo,X, y)\n    res['fs_time']= fs_time\n    if fs_algo==\"ReliefF\":\n        if best_feature.pvalues_==None:\n            empty_feature=True",
        "detail": "comparison",
        "documentation": {}
    },
    {
        "label": "k_level",
        "kind": 2,
        "importPath": "comparison",
        "description": "comparison",
        "peekOfCode": "def k_level(k,X,y,best_feature=[], best_feature_index=[]):\n    print(\"k level:\",k)\n    res={}\n    empty_feature= best_feature== []\n    clf_list= get_clf_dict().items()\n    if empty_feature:\n        res['chosen_features']= []\n        res['feature_rank']= []\n        for clf_name, clf in clf_list:\n            res[clf_name]={}",
        "detail": "comparison",
        "documentation": {}
    },
    {
        "label": "evalute",
        "kind": 2,
        "importPath": "comparison",
        "description": "comparison",
        "peekOfCode": "def evalute(y_true,y_pred, y_prob, loo=False):\n    if y_prob.shape[1] ==2 or  y_prob.shape[1] ==1:\n        # if loo:\n        y_prob=y_prob[:,0]\n        pr_auc= average_precision_score(y_true, y_prob)\n        # auc= roc_auc_score(y_true, y_prob)\n        fpr, tpr, thresholds = roc_curve(y_true,y_prob)\n        auc_Score = auc(fpr, tpr)\n    else:\n        np.argmax(y_prob, 0)",
        "detail": "comparison",
        "documentation": {}
    },
    {
        "label": "feature_selection",
        "kind": 2,
        "importPath": "comparison",
        "description": "comparison",
        "peekOfCode": "def feature_selection(fs_algo,X_train, y_train):\n    start = timer()\n    if  fs_algo==\"f_classif\":\n        return SelectFdr(score_func=f_classif,alpha=0.1).fit(X_train,y_train),timer()-start\n    elif fs_algo==\"MRMR\":\n        return SelectKBest(score_func=MRMR.mrmr,k=100).fit(X_train, y_train),timer()-start\n    elif fs_algo==\"ReliefF\":\n        return SelectKBest(score_func=ReliefF.ReliefF,k=100).fit(X_train, y_train),timer()-start\n    elif fs_algo==\"SVM\":\n        return RFE(SVC(kernel='linear'),n_features_to_select=100,step=1).fit(X_train, y_train),timer()-start",
        "detail": "comparison",
        "documentation": {}
    },
    {
        "label": "get_fold",
        "kind": 2,
        "importPath": "comparison",
        "description": "comparison",
        "peekOfCode": "def get_fold(x):\n    if len(x)<50:\n        fold_func = LeavePOut(2)\n    elif len(x)<=100:\n        fold_func = LeavePOut(1)\n    elif len(x)<=1000:\n        fold_func = StratifiedKFold(n_splits=10)\n    else:\n        fold_func = StratifiedKFold(n_splits=5) \n    return fold_func",
        "detail": "comparison",
        "documentation": {}
    },
    {
        "label": "clf_res",
        "kind": 2,
        "importPath": "comparison",
        "description": "comparison",
        "peekOfCode": "def clf_res(res,clf):\n    # res= k_value_dict[k][clf]\n    clf_df= pd.DataFrame.from_dict(res)\n    clf_df.index = clf_df.index.set_names(['metric'])\n    clf_df.reset_index(inplace=True)\n    clf_df[\"Learning algorithm\"]= clf\n    return clf_df\ndef turn_resDict_to_df(results):\n    all_df=[]\n    for fold,fs_algo_lst in results.items():",
        "detail": "comparison",
        "documentation": {}
    },
    {
        "label": "turn_resDict_to_df",
        "kind": 2,
        "importPath": "comparison",
        "description": "comparison",
        "peekOfCode": "def turn_resDict_to_df(results):\n    all_df=[]\n    for fold,fs_algo_lst in results.items():\n        for fs_algo in fs_algo_lst:\n            for fs_algo_name in fs_algo.keys():\n                k_value_dict= fs_algo[fs_algo_name]\n                k_df= pd.DataFrame()\n                fs_time= k_value_dict[\"fs_time\"]\n                for k in list(k_value_dict.keys())[1:]:\n                    res_df= pd.DataFrame()",
        "detail": "comparison",
        "documentation": {}
    },
    {
        "label": "imputation",
        "kind": 6,
        "importPath": "data_preprocessing",
        "description": "data_preprocessing",
        "peekOfCode": "class imputation(BaseEstimator, TransformerMixin):\n    def fit(self, X, y=None):\n        self.X = X\n        imp_mean = SimpleImputer(missing_values=np.nan, strategy='mean')\n        X = imp_mean.fit_transform(X)\n        return X\n    def transform(self, X):\n        return self.X\n    def fit_transform(self, X, y=None):\n        X = self.fit(X)",
        "detail": "data_preprocessing",
        "documentation": {}
    },
    {
        "label": "variance",
        "kind": 6,
        "importPath": "data_preprocessing",
        "description": "data_preprocessing",
        "peekOfCode": "class variance(BaseEstimator, TransformerMixin):\n    def fit(self, X, y=None):\n        scaler = StandardScaler()\n        X = scaler.fit_transform(X)\n        #selector = VarianceThreshold()\n        #X = selector.fit_transform(X)\n        pt = PowerTransformer()\n        X = pt.fit_transform(X)\n        return X\n    def transform(self, X):",
        "detail": "data_preprocessing",
        "documentation": {}
    },
    {
        "label": "fillna",
        "kind": 2,
        "importPath": "data_preprocessing",
        "description": "data_preprocessing",
        "peekOfCode": "def fillna(X, y):\n    y = y.astype(str).astype(float)\n    y = y.fillna(y.max() + 1)\n    y = y.astype(int).values\n    return X, y\ndef read_bioconductor(db):\n    df = pd.read_csv(db, header=0)\n    df = df.T\n    cols = df.iloc[0, :]\n    cols = cols[1:]",
        "detail": "data_preprocessing",
        "documentation": {}
    },
    {
        "label": "read_bioconductor",
        "kind": 2,
        "importPath": "data_preprocessing",
        "description": "data_preprocessing",
        "peekOfCode": "def read_bioconductor(db):\n    df = pd.read_csv(db, header=0)\n    df = df.T\n    cols = df.iloc[0, :]\n    cols = cols[1:]\n    df = df[1:]\n    X = df.iloc[:, 1:]\n    y = df.iloc[:, 0]\n    X, y = fillna(X, y)\n    X.columns = cols",
        "detail": "data_preprocessing",
        "documentation": {}
    },
    {
        "label": "read_scikit_mat",
        "kind": 2,
        "importPath": "data_preprocessing",
        "description": "data_preprocessing",
        "peekOfCode": "def read_scikit_mat(db):\n    mat = scipy.io.loadmat(db)\n    X = mat['X']\n    X = pd.DataFrame(X)\n    y = mat['Y'][:, 0]\n    return X, y\ndef read_ARFF(db):\n    df = arff.loadarff(db)\n    df = pd.DataFrame(df[0])\n    X = df.iloc[:, :-1]",
        "detail": "data_preprocessing",
        "documentation": {}
    },
    {
        "label": "read_ARFF",
        "kind": 2,
        "importPath": "data_preprocessing",
        "description": "data_preprocessing",
        "peekOfCode": "def read_ARFF(db):\n    df = arff.loadarff(db)\n    df = pd.DataFrame(df[0])\n    X = df.iloc[:, :-1]\n    y = df.iloc[:, -1]\n    label_encoder = LabelEncoder().fit(y)\n    y = label_encoder.transform(y)\n    return X, y\ndef read_datamicroarray(db):\n    df = pd.read_csv(db, header=None)",
        "detail": "data_preprocessing",
        "documentation": {}
    },
    {
        "label": "read_datamicroarray",
        "kind": 2,
        "importPath": "data_preprocessing",
        "description": "data_preprocessing",
        "peekOfCode": "def read_datamicroarray(db):\n    df = pd.read_csv(db, header=None)\n    X = df.iloc[:, :-1]\n    y = df.iloc[:, -1]\n    X, y = fillna(X, y)\n    return X, y\ndef read_and_fix(db):\n    function_name = {'bioconductor': read_bioconductor, 'scikit': read_scikit_mat, 'ARFF': read_ARFF, 'datamicroarray': read_datamicroarray}\n    file_type = db.split(\"/\")[1].split(\"_\")[0]\n    X, y = function_name[file_type](db)",
        "detail": "data_preprocessing",
        "documentation": {}
    },
    {
        "label": "read_and_fix",
        "kind": 2,
        "importPath": "data_preprocessing",
        "description": "data_preprocessing",
        "peekOfCode": "def read_and_fix(db):\n    function_name = {'bioconductor': read_bioconductor, 'scikit': read_scikit_mat, 'ARFF': read_ARFF, 'datamicroarray': read_datamicroarray}\n    file_type = db.split(\"/\")[1].split(\"_\")[0]\n    X, y = function_name[file_type](db)\n    return X, y\ndef to_csv(X, y, name, cols):\n    suffix_name = name.split(\"/\")[1].split(\".\")[0]\n    df_array = np.column_stack((X,y))\n    df = pd.DataFrame(df_array)\n    cols = np.append(cols, \"label\")",
        "detail": "data_preprocessing",
        "documentation": {}
    },
    {
        "label": "to_csv",
        "kind": 2,
        "importPath": "data_preprocessing",
        "description": "data_preprocessing",
        "peekOfCode": "def to_csv(X, y, name, cols):\n    suffix_name = name.split(\"/\")[1].split(\".\")[0]\n    df_array = np.column_stack((X,y))\n    df = pd.DataFrame(df_array)\n    cols = np.append(cols, \"label\")\n    df.to_csv('after_preprocess/' + suffix_name + \".csv\", index=False, header=cols)\npath = 'Data/'\nall_files = []\nfor file in os.listdir(path):\n    if os.path.isfile(os.path.join(path,file)):",
        "detail": "data_preprocessing",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "data_preprocessing",
        "description": "data_preprocessing",
        "peekOfCode": "path = 'Data/'\nall_files = []\nfor file in os.listdir(path):\n    if os.path.isfile(os.path.join(path,file)):\n        all_files.append(os.path.join(path,file))\nfor name in all_files:\n    X, y = read_and_fix(name)\n    cols = X.columns\n    pipe = Pipeline(steps=[('imputation', imputation()), ('variance_thresh', VarianceThreshold()), ('normalization', StandardScaler()),\n                           ('power_transformer', PowerTransformer())])",
        "detail": "data_preprocessing",
        "documentation": {}
    },
    {
        "label": "all_files",
        "kind": 5,
        "importPath": "data_preprocessing",
        "description": "data_preprocessing",
        "peekOfCode": "all_files = []\nfor file in os.listdir(path):\n    if os.path.isfile(os.path.join(path,file)):\n        all_files.append(os.path.join(path,file))\nfor name in all_files:\n    X, y = read_and_fix(name)\n    cols = X.columns\n    pipe = Pipeline(steps=[('imputation', imputation()), ('variance_thresh', VarianceThreshold()), ('normalization', StandardScaler()),\n                           ('power_transformer', PowerTransformer())])\n    X = pipe.fit_transform(X, y)",
        "detail": "data_preprocessing",
        "documentation": {}
    },
    {
        "label": "error_rate",
        "kind": 2,
        "importPath": "functionHO",
        "description": "functionHO",
        "peekOfCode": "def error_rate(xtrain, ytrain, x, opts):\n    # parameters\n    k     = opts['k']\n    fold  = opts['fold']\n    xt    = fold['xt']\n    yt    = fold['yt']\n    xv    = fold['xv']\n    yv    = fold['yv']\n    # Number of instances\n    num_train = np.size(xt, 0)",
        "detail": "functionHO",
        "documentation": {}
    },
    {
        "label": "Fun",
        "kind": 2,
        "importPath": "functionHO",
        "description": "functionHO",
        "peekOfCode": "def Fun(xtrain, ytrain, x, opts):\n    # Parameters\n    alpha    = 0.99\n    beta     = 1 - alpha\n    # Original feature size\n    max_feat = len(x)\n    # Number of selected features\n    num_feat = np.sum(x == 1)\n    # Solve if no feature selected\n    if num_feat == 0:",
        "detail": "functionHO",
        "documentation": {}
    },
    {
        "label": "freeze_seed",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def freeze_seed(seed):\n    random.seed(seed)\n    np.random.seed(seed)\ndef main(database_name):\n    freeze_seed(42)\n    db=pd.read_csv(\"after_preprocess/\"+database_name+\".csv\",header=0)\n    results=comparison.run_grid_search(db.values)\n    results[\"Dataset Name\"]=database_name\n    results[\"Number of samples\"]=db.shape[0]\n    results[\"Original Number of features\"]=db.shape[1]-1",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def main(database_name):\n    freeze_seed(42)\n    db=pd.read_csv(\"after_preprocess/\"+database_name+\".csv\",header=0)\n    results=comparison.run_grid_search(db.values)\n    results[\"Dataset Name\"]=database_name\n    results[\"Number of samples\"]=db.shape[0]\n    results[\"Original Number of features\"]=db.shape[1]-1\n    #save results into pickle file\n    with open(\"results/\"+database_name+\".pkl\", \"wb\") as f:\n        pickle.dump(results, f)",
        "detail": "main",
        "documentation": {}
    }
]